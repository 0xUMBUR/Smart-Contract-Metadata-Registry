{"address":"0x460612682cE6ED51C1A9813F6938671D9D135d6D","name":"","metadata":{"compiler":{"version":"0.6.12+commit.27d51765"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"_vault","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"profit","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"loss","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"debtPayment","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"debtOutstanding","type":"uint256"}],"name":"Harvested","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"debtThreshold","type":"uint256"}],"name":"UpdatedDebtThreshold","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"newKeeper","type":"address"}],"name":"UpdatedKeeper","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"profitFactor","type":"uint256"}],"name":"UpdatedProfitFactor","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"delay","type":"uint256"}],"name":"UpdatedReportDelay","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"rewards","type":"address"}],"name":"UpdatedRewards","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"newStrategist","type":"address"}],"name":"UpdatedStrategist","type":"event"},{"inputs":[{"internalType":"address","name":"a","type":"address"}],"name":"addLender","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"apiVersion","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"debtThreshold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"emergencyExit","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"estimateAdjustPosition","outputs":[{"internalType":"uint256","name":"_lowest","type":"uint256"},{"internalType":"uint256","name":"_lowestApr","type":"uint256"},{"internalType":"uint256","name":"_highest","type":"uint256"},{"internalType":"uint256","name":"_potential","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"estimatedAPR","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"newDebtLimit","type":"uint256"}],"name":"estimatedFutureAPR","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"estimatedTotalAssets","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"externalOracle","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"a","type":"address"}],"name":"forceRemoveLender","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"harvest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"callCost","type":"uint256"}],"name":"harvestTrigger","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"keeper","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lendStatuses","outputs":[{"components":[{"internalType":"string","name":"name","type":"string"},{"internalType":"uint256","name":"assets","type":"uint256"},{"internalType":"uint256","name":"rate","type":"uint256"},{"internalType":"address","name":"add","type":"address"}],"internalType":"struct Strategy.lendStatus[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"lenders","outputs":[{"internalType":"contract IGenericLender","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lentTotalAssets","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"lender","type":"address"},{"internalType":"uint16","name":"share","type":"uint16"}],"internalType":"struct Strategy.lenderRatio[]","name":"_newPositions","type":"tuple[]"}],"name":"manualAllocation","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newStrategy","type":"address"}],"name":"migrate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"minReportDelay","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"numLenders","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"profitFactor","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"rewards","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"a","type":"address"}],"name":"safeRemoveLender","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_debtThreshold","type":"uint256"}],"name":"setDebtThreshold","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"setEmergencyExit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_keeper","type":"address"}],"name":"setKeeper","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_delay","type":"uint256"}],"name":"setMinReportDelay","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"}],"name":"setPriceOracle","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_profitFactor","type":"uint256"}],"name":"setProfitFactor","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_rewards","type":"address"}],"name":"setRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_strategist","type":"address"}],"name":"setStrategist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"strategist","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"}],"name":"sweep","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"tend","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"callCost","type":"uint256"}],"name":"tendTrigger","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"uniswapRouter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"vault","outputs":[{"internalType":"contract VaultAPI","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"want","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"wantToEthOracle","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"weth","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amountNeeded","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"kind":"dev","methods":{"apiVersion()":{"details":"The Strategy's version must match the Vault's `API_VERSION`.","returns":{"_0":"A string which holds the current API version of this contract."}},"estimatedTotalAssets()":{"details":"Care must be taken in using this function, since it relies on external  systems, which could be manipulated by the attacker to give an inflated  (or reduced) value produced by this function, based on current on-chain  conditions (e.g. this function is possible to influence through  flashloan attacks, oracle manipulations, or other DeFi attack  mechanisms).  It is up to governance to use this function to correctly order this  Strategy relative to its peers in the withdrawal queue to minimize  losses for the Vault based on sudden withdrawals. This value should be  higher than the total debt of the Strategy and higher than its expected  value to be \"safe\".","returns":{"_0":"The estimated total assets in this Strategy."}},"harvest()":{"details":"When `harvest()` is called, the Strategy reports to the Vault (via  `vault.report()`), so in some cases `harvest()` must be called in order  to take in profits, to borrow newly available funds from the Vault, or  otherwise adjust its position. In other cases `harvest()` must be  called to report to the Vault on the Strategy's position, especially if  any losses have occurred."},"harvestTrigger(uint256)":{"details":"`callCost` must be priced in terms of `want`.  This call and `tendTrigger` should never return `true` at the  same time.  See `minReportDelay`, `profitFactor`, `debtThreshold` to adjust the  strategist-controlled parameters that will influence whether this call  returns `true` or not. These parameters will be used in conjunction  with the parameters reported to the Vault (see `params`) to determine  if calling `harvest()` is merited.  It is expected that an external system will check `harvestTrigger()`.  This could be a script run off a desktop or cloud bot (e.g.  https://github.com/iearn-finance/yearn-vaults/blob/master/scripts/keep.py),  or via an integration with the Keep3r network (e.g.  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).","params":{"callCost":"The keeper's estimated cast cost to call `harvest()`."},"returns":{"_0":"`true` if `harvest()` should be called, `false` otherwise."}},"migrate(address)":{"details":"The new Strategy's Vault must be the same as this Strategy's Vault.","params":{"_newStrategy":"The Strategy to migrate to."}},"name()":{"details":"You can use this field to manage the \"version\" of this Strategy, e.g.  `StrategySomethingOrOtherV1`. However, \"API Version\" is managed by  `apiVersion()` function above.","returns":{"_0":"This Strategy's name."}},"setDebtThreshold(uint256)":{"params":{"_debtThreshold":"How big of a loss this Strategy may carry without being required to report to the Vault."}},"setEmergencyExit()":{"details":"See `vault.setEmergencyShutdown()` and `harvest()` for further details."},"setKeeper(address)":{"params":{"_keeper":"The new address to assign as `keeper`."}},"setMinReportDelay(uint256)":{"params":{"_delay":"The minimum number of blocks to wait between harvests."}},"setProfitFactor(uint256)":{"params":{"_profitFactor":"A ratio to multiply anticipated `harvest()` gas cost against."}},"setRewards(address)":{"params":{"_rewards":"The address to use for collecting rewards."}},"setStrategist(address)":{"params":{"_strategist":"The new address to assign as `strategist`."}},"sweep(address)":{"details":"Implement `protectedTokens()` to specify any additional tokens that  should be protected from sweeping in addition to `want`.","params":{"_token":"The token to transfer out of this vault."}},"tendTrigger(uint256)":{"details":"`callCost` must be priced in terms of `want`.  This call and `harvestTrigger()` should never return `true` at the same  time.","params":{"callCost":"The keeper's estimated cast cost to call `tend()`."},"returns":{"_0":"`true` if `tend()` should be called, `false` otherwise."}},"withdraw(uint256)":{"params":{"_amountNeeded":"How much `want` to withdraw."}}},"version":1},"userdoc":{"kind":"user","methods":{"apiVersion()":{"notice":"Used to track which version of `StrategyAPI` this Strategy  implements."},"estimatedTotalAssets()":{"notice":"Provide an accurate estimate for the total amount of assets  (principle + return) that this Strategy is currently managing,  denominated in terms of `want` tokens.  This total should be \"realizable\" e.g. the total value that could  *actually* be obtained from this Strategy if it were to divest its  entire position based on current on-chain conditions."},"harvest()":{"notice":"Harvests the Strategy, recognizing any profits or losses and adjusting  the Strategy's position.  In the rare case the Strategy is in emergency shutdown, this will exit  the Strategy's position.  This may only be called by governance, the strategist, or the keeper."},"harvestTrigger(uint256)":{"notice":"Provide a signal to the keeper that `harvest()` should be called. The  keeper will provide the estimated gas cost that they would pay to call  `harvest()`, and this function should use that estimate to make a  determination if calling it is \"worth it\" for the keeper. This is not  the only consideration into issuing this trigger, for example if the  position would be negatively affected if `harvest()` is not called  shortly, then this can return `true` even if the keeper might be \"at a  loss\" (keepers are always reimbursed by Yearn)."},"migrate(address)":{"notice":"Transfers all `want` from this Strategy to `_newStrategy`.  This may only be called by governance or the Vault."},"name()":{"notice":"This Strategy's name."},"setDebtThreshold(uint256)":{"notice":"Sets how far the Strategy can go into loss without a harvest and report  being required.  By default this is 0, meaning any losses would cause a harvest which  will subsequently report the loss to the Vault for tracking. (See  `harvestTrigger()` for more details.)  This may only be called by governance or the strategist."},"setEmergencyExit()":{"notice":"Activates emergency exit. Once activated, the Strategy will exit its  position upon the next harvest, depositing all funds into the Vault as  quickly as is reasonable given on-chain conditions.  This may only be called by governance or the strategist."},"setKeeper(address)":{"notice":"Used to change `keeper`.  `keeper` is the only address that may call `tend()` or `harvest()`,  other than `governance()` or `strategist`. However, unlike  `governance()` or `strategist`, `keeper` may *only* call `tend()`  and `harvest()`, and no other authorized functions, following the  principle of least privilege.  This may only be called by governance or the strategist."},"setMinReportDelay(uint256)":{"notice":"Used to change `minReportDelay`. `minReportDelay` is the minimum number  of blocks that should pass before `harvest()` is called.  For external keepers (such as the Keep3r network), this is the minimum  time between jobs, to prevent excessive costs. (see `harvestTrigger()`  for more details.)  This may only be called by governance or the strategist."},"setProfitFactor(uint256)":{"notice":"Used to change `profitFactor`. `profitFactor` is used to determine  if it's worthwhile to harvest, given gas costs. (See `harvestTrigger()`  for more details.)  This may only be called by governance or the strategist."},"setRewards(address)":{"notice":"Used to change `rewards`. Any distributed rewards will cease flowing  to the old address and begin flowing to this address once the change  is in effect.  This will not change any Strategy reports in progress, only  new reports made after this change goes into effect.  This may only be called by the strategist."},"setStrategist(address)":{"notice":"Used to change `strategist`.  This may only be called by governance or the existing strategist."},"sweep(address)":{"notice":"Removes tokens from this Strategy that are not the type of tokens  managed by this Strategy. This may be used in case of accidentally  sending the wrong kind of token to this Strategy.  Tokens will be sent to `governance()`.  This will fail if an attempt is made to sweep `want`, or any tokens  that are protected by this Strategy.  This may only be called by governance."},"tend()":{"notice":"Adjust the Strategy's position. The purpose of tending isn't to  realize gains, but to maximize yield by reinvesting any returns.  See comments on `adjustPosition()`.  This may only be called by governance, the strategist, or the keeper."},"tendTrigger(uint256)":{"notice":"Provide a signal to the keeper that `tend()` should be called. The  keeper will provide the estimated gas cost that they would pay to call  `tend()`, and this function should use that estimate to make a  determination if calling it is \"worth it\" for the keeper. This is not  the only consideration into issuing this trigger, for example if the  position would be negatively affected if `tend()` is not called  shortly, then this can return `true` even if the keeper might be  \"at a loss\" (keepers are always reimbursed by Yearn)."},"withdraw(uint256)":{"notice":"Withdraws `_amountNeeded` to `vault`.  This may only be called by the Vault."}},"version":1}},"settings":{"compilationTarget":{"browser/genLender.sol":"Strategy"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"browser/genLender.sol":{"keccak256":"0x7d02ca72378e35ab9ac4f3e876c6ef556b8715539f47651b563ba2a307d7e3ac","license":"GPL-3.0","urls":["bzz-raw://61ad2198460b07150a09eac4d06befd299b6a9b2c69460305a029f5d4484228b","dweb:/ipfs/QmaxdyAkAm5gBsQbHkq39s6GvGTrvcGB4zsryMHAwitJW1"]}},"version":1},"version":1,"checkPoints":[]}