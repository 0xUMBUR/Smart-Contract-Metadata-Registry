{"address":"0xB18D7b29555f7Ae9D4bd9BCF19D666FE1C896c43","name":"","metadata":{"compiler":{"version":"0.6.12+commit.27d51765"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"vault_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"bytes32","name":"guestRoot","type":"bytes32"}],"name":"ProveInvitation","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"guestRoot","type":"bytes32"}],"name":"SetGuestRoot","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"cap","type":"uint256"}],"name":"SetUserDepositCap","type":"event"},{"inputs":[{"internalType":"address","name":"_guest","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"authorized","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"bouncer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"guestRoot","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"guests","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"}],"name":"proveInvitation","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"remainingDepositAllowed","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"guestRoot_","type":"bytes32"}],"name":"setGuestRoot","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"_guests","type":"address[]"},{"internalType":"bool[]","name":"_invited","type":"bool[]"}],"name":"setGuests","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"cap_","type":"uint256"}],"name":"setUserDepositCap","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"userDepositCap","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"vault","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"vaultBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"devdoc":{"details":"For a Vyper implementation of this contract containing additional functionality, see https://github.com/banteg/guest-list/blob/master/contracts/GuestList.vy The bouncer can invite arbitrary guests A guest can be added permissionlessly with proof of inclusion in current merkle set The bouncer can change the merkle root at any time Merkle-based permission that has been claimed cannot be revoked permissionlessly. Any guests can be revoked by the bouncer at-will The TVL cap is based on the number of want tokens in the underlying vaults. This can only be made more permissive over time. If decreased, existing TVL is maintained and no deposits are possible until the TVL has gone below the threshold A variant of the yearn AffiliateToken that supports guest list control of deposits A guest list that gates access by merkle root and a TVL cap","kind":"dev","methods":{"authorized(address,uint256)":{"details":"Note that `_amount` isn't checked to keep test setup simple, since from the vault tests' perspective this is a pass/fail call anyway.","params":{"_guest":"The guest's address to check."}},"constructor":{"details":"Note that since this is just for testing, you're unable to change `bouncer`."},"setGuests(address[],bool[])":{"params":{"_guests":"The guests to add or update.","_invited":"A flag for each guest at the matching index, inviting or uninviting the guest."}}},"version":1},"userdoc":{"kind":"user","methods":{"authorized(address,uint256)":{"notice":"Check if a guest with a bag of a certain size is allowed into the party."},"constructor":"Create the test guest list, setting the message sender as `bouncer`.","proveInvitation(address,bytes32[])":{"notice":"Permissionly prove an address is included in the current merkle root, thereby granting accessNote that the list is designed to ONLY EXPAND in future instancesThe admin does retain the ability to ban individual addresses"},"setGuestRoot(bytes32)":{"notice":"Set the merkle root to verify invitation proofs against.Note that accounts not included in the root will still be invited if their inviation was previously approved."},"setGuests(address[],bool[])":{"notice":"Invite guests or kick them from the party."},"setUserDepositCap(uint256)":{"notice":"Set the merkle root to verify invitation proofs against.Note that accounts not included in the root will still be invited if their inviation was previously approved."}},"notice":"A basic guest list contract for testing.","version":1}},"settings":{"compilationTarget":{"contracts/VipCapped.sol":"VipCappedGuestList"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":false,"runs":200},"remappings":[]},"sources":{"contracts/VipCapped.sol":{"keccak256":"0x8e71b25fe67280b965dde17af667abd0c37e6c259d28920da75cc2b28626d6f5","license":"MIT","urls":["bzz-raw://af3d08f528da72f9664bb5d4a932d18cee2f9a8039955a14a71c2da9ba38520a","dweb:/ipfs/QmVbaZ1KjpTrQ8RA5JXogqxv2AD8w6qFJA9VRp2aNAcGXZ"]}},"version":1},"version":1,"checkPoints":[]}