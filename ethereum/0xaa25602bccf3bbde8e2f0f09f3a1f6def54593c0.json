{"address":"0xAA25602bccF3bBdE8E2F0F09f3a1f6DEF54593c0","name":"","metadata":{"compiler":{"version":"0.6.6+commit.6c089d02"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"n","type":"uint256"}],"name":"getBlockhash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"n","type":"uint256"}],"name":"store","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"storeEarliest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"n","type":"uint256"},{"internalType":"bytes","name":"header","type":"bytes"}],"name":"storeVerifyHeader","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"methods":{"getBlockhash(uint256)":{"params":{"n":"the number of the block whose blockhash should be returned"}},"store(uint256)":{"params":{"n":"the number of the block whose blockhash should be stored"}},"storeVerifyHeader(uint256,bytes)":{"params":{"header":"the rlp-encoded blockheader of block n+1. We verify its correctness by checking  that it hashes to a stored blockhash, and then extract parentHash to get the n-th blockhash.","n":"the number of the block whose blockhash should be stored"}}},"title":"BlockhashStore"},"userdoc":{"methods":{"getBlockhash(uint256)":{"notice":"gets a blockhash from the store. If no hash is known, this function reverts."},"store(uint256)":{"notice":"stores blockhash of a given block, assuming it is available through BLOCKHASH"},"storeEarliest()":{"notice":"stores blockhash of the earliest block still available through BLOCKHASH."},"storeVerifyHeader(uint256,bytes)":{"notice":"stores blockhash after verifying blockheader of child/subsequent block"}},"notice":"This contract provides a way to access blockhashes older than  the 256 block limit imposed by the BLOCKHASH opcode.  You may assume that any blockhash stored by the contract is correct.  Note that the contract depends on the format of serialized Ethereum  blocks. If a future hardfork of Ethereum changes that format, the   logic in this contract may become incorrect and an updated version   would have to be deployed."}},"settings":{"compilationTarget":{"browser/BlockhashStore.sol":"BlockhashStore"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"browser/BlockhashStore.sol":{"keccak256":"0x178a35dad8977a3a0b82e44ee8c24b97917c6c7885ef22797be2ca84a26286b6","urls":["bzz-raw://9fb036516b1e95d4ac7a97360a090a48deb4049747c414fd24785a842a316d88","dweb:/ipfs/QmfXdhxC5TJUvtYWh119NnWb494qzeMXkWnXPXF1zWnvbH"]}},"version":1},"version":1,"checkPoints":[]}