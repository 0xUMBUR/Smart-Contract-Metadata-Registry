{"address":"0xAA407a403d38cEB8f47964d8aaF2De9C5EDFDF7e","name":"","metadata":{"compiler":{"version":"0.7.3+commit.9bfce1f6"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"supply","type":"uint256"},{"internalType":"uint256","name":"initialIndividualSupply","type":"uint256"},{"internalType":"address","name":"gateway","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"remaining","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"holder","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"uint256","name":"expiry","type":"uint256"},{"internalType":"bool","name":"allowed","type":"bool"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"totalSupply()":{"details":"Returns the amount of tokens in existence."}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"solc_0.7/Test/DAIWithInitialBalance.sol":"DAIWithInitialBalance"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[]},"sources":{"_lib/openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n","keccak256":"0xbd74f587ab9b9711801baf667db1426e4a03fd2d7f15af33e0e0d0394e7cef76","license":"MIT"},"solc_0.7/Interfaces/DAIERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.3;\n\nimport \"../../_lib/openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface DAIERC20 is IERC20 {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address holder) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n","keccak256":"0x18be6c77ea0620b180d0fd9329b3b9f51cf74303c156ca1cda0285b2e33ceade","license":"MIT"},"solc_0.7/Test/BaseERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.3;\n\nimport \"../../_lib/openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract BaseERC20 is IERC20 {\n    // //////////////////// EXTERNAL /////////////////////////////\n\n    string public constant name = \"Coin\";\n    string public constant symbol = \"COIN\";\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256 balance) {\n        (, balance) = _balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256 remaining) {\n        if (spender == _gateway) {\n            return 2**256 - 1;\n        }\n        return _allowances[owner][spender];\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool success) {\n        if (msg.sender != from && msg.sender != _gateway) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_ENOUGH_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool success) {\n        require(spender != address(0), \"INVALID_ZERO_ADDRESS\");\n        require(spender != _gateway, \"IMMUTABLE_GATEWAY_ALLOWANCE\");\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // function burn(uint256 amount) external returns (bool) {\n    //     _burn(msg.sender, amount);\n    //     return true;\n    // }\n\n    // function hasClaimed() TODO\n\n    // ////////////////////////////////////// INTERNALS ///////////////////////////////////////////\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(to != address(0), \"INVALID_ZERO_ADDRESS\");\n        (bool claimed, uint256 currentBalance) = _balanceOf(from);\n        require(currentBalance >= amount, \"NOT_ENOUGH_BALANCE\");\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[from] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[from] = currentBalance - amount;\n\n        (claimed, currentBalance) = _balanceOf(to);\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[to] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[to] = currentBalance + amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _balanceOf(address owner) internal view returns (bool claimed, uint256 balance) {\n        balance = _balances[owner];\n        if (!_claimed[owner] && _supplyClaimed < _totalSupply) {\n            claimed = false;\n            balance = _totalSupply - _supplyClaimed;\n            if (balance > _initialIndividualSupply) {\n                balance = _initialIndividualSupply;\n            }\n        } else {\n            claimed = true;\n        }\n    }\n\n    // function _mint(address to, uint256 amount) internal {\n    //     require(to != address(0), \"INVALID_ZERO_ADDRESS0\");\n    //     require(amount != 0, \"INVALID_AMOUNT\");\n    //     uint256 currentTotalSupply = _totalSupply;\n    //     uint256 newTotalSupply = currentTotalSupply + amount;\n    //     require(newTotalSupply > currentTotalSupply, \"OVERFLOW\");\n    //     _totalSupply = newTotalSupply;\n    //     _balances[to] += amount;\n    //     emit Transfer(address(0), to, amount);\n    // }\n\n    // function _burn(address from, uint256 amount) internal {\n    //     require(amount > 0, \"INVALID_AMOUNT\");\n    //     if (msg.sender != from) {\n    //         uint256 currentAllowance = _allowances[from][msg.sender];\n    //         require(\n    //             currentAllowance >= amount,\n    //             \"NOT_ENOUGH_ALLOWANCE\"\n    //         );\n    //         if (currentAllowance != (2**256) - 1) {\n    //             // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n    //             _allowances[from][msg.sender] = currentAllowance - amount;\n    //         }\n    //     }\n\n    //     uint256 currentBalance = balanceOf(from);\n    //     require(currentBalance >= amount, \"NOT_ENOUGH_BALANCE\");\n    //     _balances[from] = currentBalance - amount;\n    //     _totalSupply -= amount;\n    //     emit Transfer(from, address(0), amount);\n    // }\n\n    // /////////////////////////////////// STORAGE SLOTS /////////////////////////////////////////\n\n    uint256 internal immutable _totalSupply;\n    uint256 internal immutable _initialIndividualSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _supplyClaimed;\n    mapping(address => bool) internal _claimed; // TODO optimize it by storing it in the same slot as _balances\n\n    address internal immutable _gateway;\n\n    // //////////////////////////////////// CONSTRUCTOR ///////////////////////////////////////////\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) {\n        _totalSupply = supply;\n        _initialIndividualSupply = initialIndividualSupply;\n        _gateway = gateway;\n    }\n}\n","keccak256":"0x26f7933456de3ea4bbed01137b2876e982ef99b5833d554ce593d1b731c526ab","license":"MIT"},"solc_0.7/Test/DAIWithInitialBalance.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.3;\n\nimport \"./BaseERC20.sol\";\nimport \"../Interfaces/DAIERC20.sol\";\n\ncontract DAIWithInitialBalance is BaseERC20, DAIERC20 {\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 internal constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, holder, spender, nonce, expiry, allowed))\n            )\n        );\n\n        require(holder != address(0), \"Dai/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n        require(expiry == 0 || block.timestamp <= expiry, \"Dai/permit-expired\");\n        require(nonce == _nonces[holder]++, \"Dai/invalid-nonce\");\n        uint256 wad = allowed ? uint256(-1) : 0;\n        _allowances[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n\n    // /////////////////////////////////// STORAGE SLOTS /////////////////////////////////////////\n\n    /*immutable*/\n    bytes32 internal _DOMAIN_SEPARATOR;\n    mapping(address => uint256) internal _nonces;\n\n    // //////////////////////////////////// CONSTRUCTOR ///////////////////////////////////////////\n\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) BaseERC20(supply, initialIndividualSupply, gateway) {\n        // TODO chainId\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                address(this)\n            )\n        );\n    }\n}\n","keccak256":"0x8d434b4a5847dffea7d4d02264dc2c9f79b10ec4dd4d4934725fe09dcfe0afc4","license":"MIT"}},"version":1},"version":1,"checkPoints":[]}