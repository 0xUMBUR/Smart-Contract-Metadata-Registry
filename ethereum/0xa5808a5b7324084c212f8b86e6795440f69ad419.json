{"address":"0xA5808A5B7324084c212F8B86e6795440f69AD419","name":"","metadata":{"compiler":{"version":"0.6.12+commit.27d51765"},"language":"Solidity","output":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"uint256","name":"windowIndex","type":"uint256"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":false,"internalType":"uint256","name":"accountIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"address","name":"rewardToken","type":"address"}],"name":"Claimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"windowIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"rewardsDeposited","type":"uint256"},{"indexed":true,"internalType":"address","name":"rewardToken","type":"address"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"CreatedWindow","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"windowIndex","type":"uint256"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"DeleteWindow","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"address","name":"currency","type":"address"}],"name":"WithdrawRewards","type":"event"},{"inputs":[{"components":[{"internalType":"uint256","name":"windowIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"accountIndex","type":"uint256"},{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"}],"internalType":"struct MerkleDistributor.Claim","name":"_claim","type":"tuple"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"windowIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"accountIndex","type":"uint256"},{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"}],"internalType":"struct MerkleDistributor.Claim[]","name":"claims","type":"tuple[]"}],"name":"claimMulti","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"windowIndex","type":"uint256"}],"name":"deleteWindow","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"windowIndex","type":"uint256"},{"internalType":"uint256","name":"accountIndex","type":"uint256"}],"name":"isClaimed","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"merkleWindows","outputs":[{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"contract IERC20","name":"rewardToken","type":"address"},{"internalType":"string","name":"ipfsHash","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextCreatedIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"rewardsToDeposit","type":"uint256"},{"internalType":"address","name":"rewardToken","type":"address"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"string","name":"ipfsHash","type":"string"}],"name":"setWindow","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"windowIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"accountIndex","type":"uint256"},{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"}],"internalType":"struct MerkleDistributor.Claim","name":"_claim","type":"tuple"}],"name":"verifyClaim","outputs":[{"internalType":"bool","name":"valid","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"rewardCurrency","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawRewards","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"details":"The Merkle trees are not validated in any way, so the system assumes the contract owner behaves honestly.","kind":"dev","methods":{"claim((uint256,uint256,uint256,address,bytes32[]))":{"details":"If the `_claim`'s `amount`, `accountIndex`, and `account` do not exactly match the         values stored in the merkle root for the `_claim`'s `windowIndex` this method         will revert.","params":{"_claim":"claim object describing amount, accountIndex, account, window index, and merkle proof."}},"claimMulti((uint256,uint256,uint256,address,bytes32[])[])":{"details":"Optimistically tries to batch together consecutive claims for the same account and same         reward token to reduce gas. Therefore, the most gas-cost-optimal way to use this method         is to pass in an array of claims sorted by account and reward currency.","params":{"claims":"array of claims to claim."}},"deleteWindow(uint256)":{"details":"Callable only by owner. Likely to be followed by a withdrawRewards call to clear contract state.","params":{"windowIndex":"merkle root index to delete."}},"isClaimed(uint256,uint256)":{"details":"This method will only work as intended if all `accountIndex`'s are unique for a given `windowIndex`.         The onus is on the Owner of this contract to submit only valid Merkle roots.","params":{"accountIndex":"account index to check within window index.","windowIndex":"merkle root to check."},"returns":{"_0":"True if claim has been executed already, False otherwise."}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setWindow(uint256,address,bytes32,string)":{"params":{"ipfsHash":"hash of IPFS object, conveniently stored for clients","merkleRoot":"merkle root describing allocation.","rewardToken":"ERC20 reward token.","rewardsToDeposit":"amount of rewards to deposit to seed this allocation."}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"verifyClaim((uint256,uint256,uint256,address,bytes32[]))":{"params":{"_claim":"claim object describing amount, accountIndex, account, window index, and merkle proof."},"returns":{"valid":"True if leaf exists."}},"withdrawRewards(address,uint256)":{"details":"Callable only by owner.","params":{"amount":"amount of rewards to withdraw.","rewardCurrency":"rewards to withdraw from contract."}}},"title":"MerkleDistributor contract.","version":1},"userdoc":{"kind":"user","methods":{"claim((uint256,uint256,uint256,address,bytes32[]))":{"notice":"Claim amount of reward tokens for account, as described by Claim input object."},"claimMulti((uint256,uint256,uint256,address,bytes32[])[])":{"notice":"Batch claims to reduce gas versus individual submitting all claims. Method will fail         if any individual claims within the batch would fail."},"deleteWindow(uint256)":{"notice":"Delete merkle root at window index."},"isClaimed(uint256,uint256)":{"notice":"Returns True if the claim for `accountIndex` has already been completed for the Merkle root at         `windowIndex`."},"setWindow(uint256,address,bytes32,string)":{"notice":"Set merkle root for the next available window index and seed allocations.Callable only by owner of this contract. Caller must have approved this contract to transfer      `rewardsToDeposit` amount of `rewardToken` or this call will fail. Importantly, we assume that the      owner of this contract correctly chooses an amount `rewardsToDeposit` that is sufficient to cover all      claims within the `merkleRoot`. Otherwise, a race condition can be created. This situation can occur      because we do not segregate reward balances by window, for code simplicity purposes.      (If `rewardsToDeposit` is purposefully insufficient to payout all claims, then the admin must      subsequently transfer in rewards or the following situation can occur).      Example race situation:          - Window 1 Tree: Owner sets `rewardsToDeposit=100` and insert proofs that give claimant A 50 tokens and            claimant B 51 tokens. The owner has made an error by not setting the `rewardsToDeposit` correctly to 101.          - Window 2 Tree: Owner sets `rewardsToDeposit=1` and insert proofs that give claimant A 1 token. The owner            correctly set `rewardsToDeposit` this time.          - At this point contract owns 100 + 1 = 101 tokens. Now, imagine the following sequence:              (1) Claimant A claims 50 tokens for Window 1, contract now has 101 - 50 = 51 tokens.              (2) Claimant B claims 51 tokens for Window 1, contract now has 51 - 51 = 0 tokens.              (3) Claimant A tries to claim 1 token for Window 2 but fails because contract has 0 tokens.          - In summary, the contract owner created a race for step(2) and step(3) in which the first claim would            succeed and the second claim would fail, even though both claimants would expect their claims to succeed."},"verifyClaim((uint256,uint256,uint256,address,bytes32[]))":{"notice":"Returns True if leaf described by {account, amount, accountIndex} is stored in Merkle root at given         window index."},"withdrawRewards(address,uint256)":{"notice":"Emergency method that transfers rewards out of the contract if the contract was configured improperly."}},"notice":"Inspired by: - https://github.com/pie-dao/vested-token-migration-app - https://github.com/Uniswap/merkle-distributor - https://github.com/balancer-labs/erc20-redeemableAllows an owner to distribute any reward ERC20 to claimants according to Merkle roots. The owner can specify         multiple Merkle roots distributions with customized reward currencies.","version":1}},"settings":{"compilationTarget":{"MerkleDistributor1.sol":"MerkleDistributor"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"MerkleDistributor1.sol":{"keccak256":"0x62950c040847fe7a1e3c8f68743cdac11007e9fc0904ad7b8f64cbd907a48635","license":"AGPL-3.0-only","urls":["bzz-raw://79f2db590310d2cf25dba7bb6758b1983fb3ae6c4a5455c125437dabd6012f0d","dweb:/ipfs/QmUi9ywTc5ALXfuVkhyCbeGdUTfeCRLuBkqwzqM8KnpHu7"]}},"version":1},"version":1,"checkPoints":[]}