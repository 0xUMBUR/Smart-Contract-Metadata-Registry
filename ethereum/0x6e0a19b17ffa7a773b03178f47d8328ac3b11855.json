{"address":"0x6e0a19B17fFa7a773b03178F47d8328AC3B11855","name":"","metadata":{"compiler":{"version":"0.6.12+commit.27d51765"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"uint256","name":"value","type":"uint256"}],"internalType":"struct Upkaran_With_TransferFrom_Restriction.Call[]","name":"calls","type":"tuple[]"}],"name":"batch","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"name":"isTrustedForwarder","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256[]","name":"","type":"uint256[]"},{"internalType":"uint256[]","name":"","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"onERC1155BatchReceived","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"onERC1155Received","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"onERC721Received","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"onFlashLoan","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"trustedForwarder","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"versionRecipient","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{"details":"Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81, or its own function selector). unUsedParam operator The address which initiated the batch transfer (i.e. _msgSender()) unUsedParam from The address which previously owned the token unUsedParam ids An array containing ids of each token being transferred (order and length must match values array) unUsedParam values An array containing amounts of each token being transferred (order and length must match ids array)","params":{"data":"Additional data with no specified format"},"returns":{"_0":"`bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed"}},"onERC1155Received(address,address,uint256,uint256,bytes)":{"details":"Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. To accept the transfer, this must return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61, or its own function selector). unUsedParam operator The address which initiated the transfer (i.e. _msgSender()) unUsedParam from The address which previously owned the token unUsedParam id The ID of the token being transferred unUsedParam value The amount of tokens being transferred","params":{"data":"Additional data with no specified format"},"returns":{"_0":"`bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed"}},"onERC721Received(address,address,uint256,bytes)":{"details":"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`."},"onFlashLoan(address,address,uint256,uint256,bytes)":{"details":"Receive a flash loan. unUsedParam initiator The initiator of the loan.* unUsedParam token The loan currency. unUsedParam amount The amount of tokens lent. unUsedParam fee The additional amount of tokens to repay.","params":{"data":"Arbitrary data structure, intended to contain user-defined parameters."},"returns":{"_0":"The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\""}},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}. Time complexity O(1), guaranteed to always use less than 30 000 gas."}},"version":1},"userdoc":{"kind":"user","methods":{"isTrustedForwarder(address)":{"notice":"return if the forwarder is trusted to forward relayed transactions to us. the forwarder is required to verify the sender's signature, and verify the call is not a replay."}},"version":1}},"settings":{"compilationTarget":{"browser/generalized_batching_solution.sol":"Upkaran_With_TransferFrom_Restriction"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":false,"runs":200},"remappings":[]},"sources":{"browser/generalized_batching_solution.sol":{"keccak256":"0x6c644ef202cef83e55faaef60bb306435faf11357c0e04c9fd6e1e024ea54604","license":"MIT","urls":["bzz-raw://3f9e23158faae06f5800b6092791bb68adad65e47c8e2bad8c633d452f543924","dweb:/ipfs/QmanqTuiNdg4YjvL8DtvDQa42VrBbLdWaHfbZFB4yDbm4Z"]}},"version":1},"version":1,"checkPoints":[]}