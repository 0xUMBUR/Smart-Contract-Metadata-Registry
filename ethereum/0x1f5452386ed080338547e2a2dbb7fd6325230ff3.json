{"address":"0x1f5452386ED080338547e2a2DBb7fd6325230FF3","name":"","metadata":{"compiler":{"version":"0.8.0+commit.c7dfd78e"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_owner","type":"address"},{"indexed":true,"internalType":"address","name":"_approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_owner","type":"address"},{"indexed":true,"internalType":"address","name":"_operator","type":"address"},{"indexed":false,"internalType":"bool","name":"_approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_from","type":"address"},{"indexed":true,"internalType":"address","name":"_to","type":"address"},{"indexed":true,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"_approved","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"_owner","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_operator","type":"address"},{"internalType":"bool","name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"_interfaceID","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"details":"Implementation of ERC-721 non-fungible token standard.","kind":"dev","methods":{"approve(address,uint256)":{"details":"Set or reaffirm the approved address for an NFT. This function can be changed to payable.","params":{"_approved":"Address to be approved for the given NFT ID.","_tokenId":"ID of the token to be approved."}},"balanceOf(address)":{"details":"Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.","params":{"_owner":"Address for whom to query the balance."},"returns":{"_0":"Balance of _owner."}},"constructor":{"details":"Contract constructor."},"getApproved(uint256)":{"details":"Get the approved address for a single NFT.","params":{"_tokenId":"ID of the NFT to query the approval of."},"returns":{"_0":"Address that _tokenId is approved for."}},"isApprovedForAll(address,address)":{"details":"Checks if `_operator` is an approved operator for `_owner`.","params":{"_operator":"The address that acts on behalf of the owner.","_owner":"The address that owns the NFTs."},"returns":{"_0":"True if approved for all, false otherwise."}},"ownerOf(uint256)":{"details":"Returns the address of the owner of the NFT. NFTs assigned to the zero address are considered invalid, and queries about them do throw.","params":{"_tokenId":"The identifier for an NFT."},"returns":{"_owner":"Address of _tokenId owner."}},"safeTransferFrom(address,address,uint256)":{"details":"Transfers the ownership of an NFT from one address to another address. This function can be changed to payable.","params":{"_from":"The current owner of the NFT.","_to":"The new owner.","_tokenId":"The NFT to transfer."}},"safeTransferFrom(address,address,uint256,bytes)":{"details":"Transfers the ownership of an NFT from one address to another address. This function can be changed to payable.","params":{"_data":"Additional data with no specified format, sent in call to `_to`.","_from":"The current owner of the NFT.","_to":"The new owner.","_tokenId":"The NFT to transfer."}},"setApprovalForAll(address,bool)":{"details":"Enables or disables approval for a third party (\"operator\") to manage all of `msg.sender`'s assets. It also emits the ApprovalForAll event.","params":{"_approved":"True if the operators is approved, false to revoke approval.","_operator":"Address to add to the set of authorized operators."}},"supportsInterface(bytes4)":{"details":"Function to check which interfaces are suported by this contract.","params":{"_interfaceID":"Id of the interface."},"returns":{"_0":"True if _interfaceID is supported, false otherwise."}},"transferFrom(address,address,uint256)":{"details":"Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.","params":{"_from":"The current owner of the NFT.","_to":"The new owner.","_tokenId":"The NFT to transfer."}}},"stateVariables":{"MAGIC_ON_ERC721_RECEIVED":{"details":"Magic value of a smart contract that can receive NFT. Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))."},"ZERO_ADDRESS":{"details":"List of revert message codes. Implementing dApp should handle showing the correct message. Based on 0xcert framework error codes."},"idToApproval":{"details":"Mapping from NFT ID to approved address."},"idToOwner":{"details":"A mapping from NFT ID to the address that owns it."},"ownerToNFTokenCount":{"details":"Mapping from owner address to count of his tokens."},"ownerToOperators":{"details":"Mapping from owner address to mapping of operator addresses."}},"version":1},"userdoc":{"kind":"user","methods":{"approve(address,uint256)":{"notice":"The zero address indicates there is no approved address. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner."},"getApproved(uint256)":{"notice":"Throws if `_tokenId` is not a valid NFT."},"safeTransferFrom(address,address,uint256)":{"notice":"This works identically to the other function with an extra data parameter, except this function just sets data to \"\""},"safeTransferFrom(address,address,uint256,bytes)":{"notice":"Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`."},"setApprovalForAll(address,bool)":{"notice":"This works even if sender doesn't own any tokens at the time."},"transferFrom(address,address,uint256)":{"notice":"The caller is responsible to confirm that `_to` is capable of receiving NFTs or else they may be permanently lost."}},"version":1}},"settings":{"compilationTarget":{"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token.sol":"NFToken"},"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":false,"runs":200},"remappings":[]},"sources":{"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/erc721-token-receiver.sol":{"keccak256":"0x4cdbea942c336fd8d00127cbe97827242a1feb2c690007dd5d615e73d1edabff","license":"MIT","urls":["bzz-raw://c9a5c1b58e5e7f144030d9e4bf4577e0739eb85b095f2d62a9511a86f9310bc8","dweb:/ipfs/QmcJZaYpTCCCpdgceE8bsUHdExDwKJWRdKhF9rm1U3n3Te"]},"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/erc721.sol":{"keccak256":"0x64681d72cd342b7ae5eab3b15ad10d629427e122f427468ccdabc3258d111bf4","license":"MIT","urls":["bzz-raw://8af9da2c63b549534772bff1f80ecd75e52b872e6eef714f243965accfc92c44","dweb:/ipfs/Qmavx3L2tpdbdMVExTXmU2SDBqo53S6DSGCK2ErMKJd8Dz"]},"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token.sol":{"keccak256":"0x8e35c2e1cc3da1f2d86fc4a1152118edc9b76bfb9b57a9d4a209cd0b9ed3e16c","license":"MIT","urls":["bzz-raw://8fe2253893518093b7fb33d3e4d47c0ba28910c10b1be12c5673b26dbddb9fa8","dweb:/ipfs/QmahYeFbh1E1ieWV2x3EVAmBp4YNs43pMGYgRcZcAzyKHd"]},"https://github.com/0xcert/ethereum-erc721/src/contracts/utils/address-utils.sol":{"keccak256":"0xd5cf8ac87ee4ebebff4e7d6f1b2bf2416016f03151dd47057e40196213cc747b","license":"MIT","urls":["bzz-raw://7e0608cf74cec01d15df48a321b425139fc5bdec9d5a178885b4f00ca33df2c5","dweb:/ipfs/QmSiobwuQdewdEzMvLp2XZp4uG5wtsM4m29j1zHWc4QJuU"]},"https://github.com/0xcert/ethereum-erc721/src/contracts/utils/erc165.sol":{"keccak256":"0x40d99a38f582ec806109b60b52343e7b6d67541c3c1472045243e077b3e4a155","license":"MIT","urls":["bzz-raw://09623177a20bb24872ff5e825281c845f4826341f5673fbed33b684ec0ff94ae","dweb:/ipfs/QmNcNEFqD4xunn2t3PfqoS6ed1esQqQJ4TW6GS3535qPaF"]},"https://github.com/0xcert/ethereum-erc721/src/contracts/utils/supports-interface.sol":{"keccak256":"0xd640bfd4f7c1c88b528912ecd2446ff7fc7e8a5df195239080d6cbe53b9d136a","license":"MIT","urls":["bzz-raw://7193870cfeb9d306f8945e92e7c382ecd20495e63863858a3d793e59ac84134f","dweb:/ipfs/QmPMD4KCiKVbfNYXtA3rXWMhD68YcWnWJJFSVszajzoHKZ"]}},"version":1},"version":1,"checkPoints":[]}